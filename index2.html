<!DOCTYPE html>
<meta charset="utf-8">
<style>

@import url(https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300|Josefin+Slab|Arvo|Lato|Vollkorn|Abril+Fatface|Old+Standard+TT|Droid+Sans|Lobster|Inconsolata|Montserrat|Playfair+Display|Karla|Alegreya|Libre+Baskerville|Merriweather|Lora|Archivo+Narrow|Neuton|Signika|Questrial|Fjalla+One|Bitter|Varela+Round);

.background {
  fill: #eee;
  pointer-events: all;
}

.map-layer {
  fill: #fff;
  stroke: #aaa;
}

.effect-layer{
  pointer-events:none;
}

text{
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-weight: 300;
}

text.big-text{
  font-size: 30px;
  font-weight: 400;
}

.effect-layer text, text.dummy-text{
  font-size: 12px;
}

</style>
<body>
 <button onclick="k2B()">k2</button>
 <button onclick="k3B()">k3</button>
 <button onclick="k4B()">k4</button>
 <button onclick="k5B()">k5</button>
 <button onclick="k6B()">k6</button>
<svg></svg>

<script src="https://d3js.org/d3.v3.min.js"></script>
<script>
var k2,k3,k4,k5,k6;
var colors =  ["red", "blue", "green", "black", "#ff00ff", "#ff6600", "#00ffff" ];
var circles;
var width = 700,
    height = 700,
    centered;

// Define color scale
var color = d3.scale.linear()
  .domain([1, 10])
  .clamp(true)
  .range(['#fff', '#FFD700']);

var projection = d3.geo.mercator()
  .scale(190000)
  // Center the Map in Colombia
  .center([-122.4167804 , 37.752876])
  .translate([width / 2, height / 2]);

var projection2 = d3.geo.mercator().center([-122.4167804 , 37.752876]).scale(190000)
  // Center the Map in Colombia
  .translate([width / 2/190000, height / 2/190000]);



var path = d3.geo.path()
  .projection(projection);

// Set svg width & height
var svg = d3.select('svg')
  .attr('width', width)
  .attr('height', height);

// Add background
svg.append('rect')
  .attr('class', 'background')
  .attr('width', width)
  .attr('height', height)
  .on('click', clicked);

var g = svg.append('g');

var effectLayer = g.append('g')
  .classed('effect-layer', true);

var mapLayer = g.append('g')
  .classed('map-layer', true);

var dummyText = g.append('text')
  .classed('dummy-text', true)
  .attr('x', 10)
  .attr('y', 30)
  .style('opacity', 0);

var bigText = g.append('text')
  .classed('big-text', true)
  .attr('x', 20)
  .attr('y', 45);

// Load map data
d3.json('sfpddistricts.geojson.json', function(error, mapData) {
  var features = mapData.features;

  // Update color scale domain based on data
  color.domain([0, d3.max(features, nameLength)]);

  // Draw each province as a path
  mapLayer.selectAll('path')
      .data(features)
    .enter().append('path')
      .attr('d', path)
      .attr('vector-effect', 'non-scaling-stroke')
      .style('fill', fillFn)
      .on('mouseover', mouseover)
      .on('mouseout', mouseout)
      .on('click', clicked);




d3.csv("k2.csv", function(data) {
 circles = mapLayer.selectAll('circle')
				      .data(data
				      	)
				      .enter()
				    .append('circle')
				      .attr('cx',function (d) { return projection([parseFloat(d.lat),parseFloat(d.lon)])[0] })
				      .attr('cy',function (d) { return projection([parseFloat(d.lat),parseFloat(d.lon)])[1]  })
				      .attr('r',  function (d) {  return returnSize(parseInt(d.type))})
				      .attr('stroke','black')
				      .attr('stroke-width',1)
				      .attr('fill', function (d) {  return returnColor(parseInt(d.type))});
				      			k2 = data;
				  }); //end of csv loading
			


}); //end of json loading

d3.csv("k3.csv", function(data) {k3=data});
d3.csv("k4.csv", function(data) {k4=data});
d3.csv("k5.csv", function(data) {k5=data});
d3.csv("k6.csv", function(data) {k6=data});


function returnSize(i)
{
	if (i>=10)
		return 10;
	else
		return 5;
}

function returnColor(i)
{	//console.log('in color');
	if (i>=10)
		return "white"

	//console.log(colors[i-1]);
	return colors[i-1];
}

// Get province name
function nameFn(d){
  return d && d.properties ? d.properties.DISTRICT : null;
}

// Get province name length
function nameLength(d){
  var n = nameFn(d);
  return n ? n.length : 0;
}

// Get province color
function fillFn(d){
  return color(nameLength(d));
}

// When clicked, zoom in
function clicked(d) {
  // var x, y, k;

  // // Compute centroid of the selected path
  // if (d && centered !== d) {
  //   var centroid = path.centroid(d);
  //   x = centroid[0];
  //   y = centroid[1];
  //   k = 4;
  //   centered = d;
  // } else {
  //   x = width / 2;
  //   y = height / 2;
  //   k = 1;
  //   centered = null;
  // }

  // // Highlight the clicked province
  // mapLayer.selectAll('path')
  //   .style('fill', function(d){return centered && d===centered ? '#D5708B' : fillFn(d);});

  // // Zoom
  // g.transition()
  //   .duration(750)
  //   .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')scale(' + k + ')translate(' + -x + ',' + -y + ')');
}

function mouseover(d){
  // Highlight hovered province
  d3.select(this).style('fill', 'orange');

  // Draw effects
}

function mouseout(d){
  // Reset province color
  mapLayer.selectAll('path')
    .style('fill', function(d){return centered && d===centered ? '#D5708B' : fillFn(d);});

  // Remove effect text
  effectLayer.selectAll('text').transition()
    .style('opacity', 0)
    .remove();

  // Clear province name
  bigText.text('');
}

// Gimmick
// Just me playing around.
// You won't need this for a regular map.

var BASE_FONT = "'Helvetica Neue', Helvetica, Arial, sans-serif";

var FONTS = [
  "Open Sans",
  "Josefin Slab",
  "Arvo",
  "Lato",
  "Vollkorn",
  "Abril Fatface",
  "Old StandardTT",
  "Droid+Sans",
  "Lobster",
  
];

// function textArt(text){
//   // Use random font
//   var fontIndex = Math.round(Math.random() * FONTS.length);
//   var fontFamily = FONTS[fontIndex] + ', ' + BASE_FONT;

//   bigText
//     .style('font-family', fontFamily)
//     .text(text);

//   // Use dummy text to compute actual width of the text
//   // getBBox() will return bounding box
//   dummyText
//     .style('font-family', fontFamily)
//     .text(text);
//   var bbox = dummyText.node().getBBox();

//   var textWidth = bbox.width;
//   var textHeight = bbox.height;
//   var xGap = 3;
//   var yGap = 1;

//   // Generate the positions of the text in the background
//   var xPtr = 0;
//   var yPtr = 0;
//   var positions = [];
//   var rowCount = 0;
//   while(yPtr < height){
//     while(xPtr < width){
//       var point = {
//         text: text,
//         index: positions.length,
//         x: xPtr,
//         y: yPtr
//       };
//       var dx = point.x - width/2 + textWidth/2;
//       var dy = point.y - height/2;
//       point.distance = dx*dx + dy*dy;

//       positions.push(point);
//       xPtr += textWidth + xGap;
//     }
//     rowCount++;
//     xPtr = rowCount%2===0 ? 0 : -textWidth/2;
//     xPtr += Math.random() * 10;
//     yPtr += textHeight + yGap;
//   }

//   var selection = effectLayer.selectAll('text')
//     .data(positions, function(d){return d.text+'/'+d.index;});

//   // Clear old ones
//   selection.exit().transition()
//     .style('opacity', 0)
//     .remove();

//   // Create text but set opacity to 0
//   selection.enter().append('text')
//     .text(function(d){return d.text;})
//     .attr('x', function(d){return d.x;})
//     .attr('y', function(d){return d.y;})
//     .style('font-family', fontFamily)
//     .style('fill', '#777')
//     .style('opacity', 0);

//   selection
//     .style('font-family', fontFamily)
//     .attr('x', function(d){return d.x;})
//     .attr('y', function(d){return d.y;});

//   // Create transtion to increase opacity from 0 to 0.1-0.5
//   // Add delay based on distance from the center of the <svg> and a bit more randomness.
//   selection.transition()
//     .delay(function(d){
//       return d.distance * 0.01 + Math.random()*1000;
//     })
//     .style('opacity', function(d){
//       return 0.1 + Math.random()*0.4;
//     });
// }


  function addPoints(data)
  {
  	mapLayer.selectAll('circle').remove();
  	mapLayer.selectAll('circle')
				      .data(data
				      	)
				      .enter()
				    .append('circle')
				      .attr('cx',function (d) { return projection([parseFloat(d.lat),parseFloat(d.lon)])[0] })
				      .attr('cy',function (d) { return projection([parseFloat(d.lat),parseFloat(d.lon)])[1]  })
				      .attr('r',  function (d) {  return returnSize(parseInt(d.type))})
				      .attr('stroke','black')
				      .attr('stroke-width',1)
				      .attr('fill', function (d) {  return returnColor(parseInt(d.type))});

				  
  }



 function k2B()
            {

            	addPoints(k2);





      //       		data =dataSet2003;
      //       		svg.selectAll('circle')
				  //     .data(data).transition().duration(1000).attr('cx',function (d) { return xScale(parseInt(d.Prostitution)) })
				  //     .attr('cy',function (d) { return yScale(parseInt(d.Theft)) })
				  //     .attr('r', function (d) { return (parseInt(d.Prostitution) + parseInt(d.Theft))/100  })
				      

				  //     text = svg.selectAll("text")
      //                  .data(data)
      //                 .transition().duration(1000)

						// var textLabels = text
      //            .attr("x", function(d) { return xScale(parseInt(d.Prostitution)) })
      //            .attr("y", function(d) { return  yScale(parseInt(d.Theft)); })
      //            .text( function (d) { return "" + d.District +  " "; })
      //          .attr("font-family", "sans-serif")
      //          .attr("font-size", "10")
      //           .attr("fill", "black");
   //	circlesEnter.exit().remove()

            }

             function k3B(){
             	addPoints(k3);
             }
             function k4B(){
             	addPoints(k4);
             }
             function k5B(){
             	addPoints(k5);
             }
             function k6B(){
             	addPoints(k6);
             }


</script>